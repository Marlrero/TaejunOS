[ORG 0x00] ; 코드의 시작 주소를 0x00로 설정함
[BITS 16]  ; 이하 코드는 16비트 코드임

SECTION .text ; text 섹션(세그먼트)을 정의

;;;;;;;;;;;;;;;;; 세그먼트 레지스터를 미리 초기화하여 BIOS가 사용했던 값을 없앰 ;;;;;;;;;;;;;;;;;
; BIOS가 부트로더를 디스크에서 읽어 메모리에 복사하는 위치는 0x07C0 ~ 512 bytes 사이에 부트로더 내용 존재
; 세그먼트 레지스터(CS제외)를 mov 명령으로 처리할 수 없고 jmp 명령과 세그먼트 레지스터 접두사를 사용해야 함
jmp 0x07C0:START ; CS 세그먼트 레지스터에 0x07c0를 복사하면서, START 레이블로 이동하라

START:
	mov ax, 0x07C0  ; 부트 로더의 시작 주소(0x07C0)를 세그먼트 레지스터 값으로 변환
	mov ds, ax ; DS 세그먼트 레지스터에 이를 저장함
	mov ax, 0xB800  ; 비디오 메모리 시작 주소(0xB800)을 세그먼트 레지스터 값으로 변환
	mov es, ax ; ES 세그먼트 레지스터에 이를 저장함

	mov si, 0  ; SI 레지스터(문자열 원본 인덱스 레지스터)를 0으로 초기화

;;;;;;;;;;;;;;;;; 화면을 초기화하는 코드 ;;;;;;;;;;;;;;;;;
.SCREENCLEARLOOP:
	mov byte [ es: si ], 0 ; 비디오 메모리 시작 주소가 위치하는 ES 세그먼트 레지스터가 가리키는 주소에 0을 복사하여 문자 삭제
	mov byte [ es: si + 1 ], 0x0A ; 비디오 메모리 시작 주소가 위치하는 ES 세그먼트 레지스터가 가리키는 주소에 +1을 하여(색 설정)
								  ; 검은 바탕에 밝은 녹색을 복사

	add si, 2  ; 문자와 속성을 모두 설정했으므로, 문자열에서 다음 문자로 이동함

	cmp si, 80 * 25 * 2  ; 화면의 전체 크기(80문자 * 25라인 * 문자 2)와 출력한 문자의 수 SI 레지스터와 비교

	jl .SCREENCLEARLOOP  ; SI 레지스터가 80 * 25 * 2보다 적다면(less) 아직 지우지 못한 영역이 있으므로 다시 .SCREENCLEARLOOP 이동

	mov si, 0  ; SI 레지스터(문자열 원본 인덱스 레지스터) 초기화
	mov di, 0  ; DI 레지스터(문자열 대상 인덱스 레지스터) 초기화


;;;;;;;;;;;;;;;;; 문자열을 출력하는 코 ;;;;;;;;;;;;;;;;;
.MESSAGELOOP:
	mov cl, byte [ si + MESSAGE1 ] ; MESSAGE1의 어드레스에서 SI 레지스터 값만큼 더한 위치의 문자를 CL 레지스터에 복사함
								   ; CL 레지스터는 CX 레지스터의 하위(Low) 1바이트를 의미
								   ; 문자열은 1바이트면 충분하므로, CX 레지스터의 하위 1바이트만을 사용함

	cmp cl, 0   ; 복사된 문자(CL 레지스터 값)와 0(널문자)을 비교함
	je .MESSAGEEND  ; 복사한 문자의 값이 0(널문자)이면 문자열 종료이므로 .MESSAGEEND로 이동하여 문자 출력 종료

	mov byte [ es: di ], cl   ; 0이 아니라면 비디오 메모리 주소 0xB800:di에 문자를 출력

	add si, 1   ; SI 레지스터에 1을 더해 다음 문자열로 이동
	add di, 2   ; DI 레지스터에 2를 더해 비디오 메모리의 다음 문자 위치로 이동함
			    ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자를 출력하려면 2를 더해야 함

	jmp .MESSAGELOOP          ; 메시지 출력 루프를 이동해 다음 문자를 출력

;;;;;;;;;;;;;;;;; 화면 최상단의 문자를 출력하는 코드 ;;;;;;;;;;;;;;;;;

; 0xB800은 비디오 메모리 주소이며, 이를 세그먼트 레지스터의 기준 주소를 설정하면 오프셋만 바꾸면 편함
;mov ax, 0xB800  ; 0xB800을 AX 레지스터에 저장함
;mov ds, ax      ; DS 세그먼트 레지스터에 AX 레지스터의 값(OxB800)을 복사함

;mov byte [ 0x00 ], 'M'   ; DS 세그먼트 레지스터의 오프셋을 0x00으로 설정하여 문자 M을 저장함
                         ; [ ]는 값 참조를 의미 -> 0xB800:0x0000
;mov byte [ 0x01 ], 0x4A  ; 0xB800:0x0001에 0x4A(빨간 배경에 밝은 녹색 속성) 복사

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.MESSAGEEND:
; 아래는 기본 코드
	jmp $  ; 현재 위치에서 무한 루프 수행

;;;;;;;;;;;;;;;;; 문자열 상수의 정의 ;;;;;;;;;;;;;;;;;
MESSAGE1:  db 'Taejun OS Boot Loader Start~!!', 0     ; 출력할 메시지 정의
										               ; 마지막은 0으로 설정해 .MESSAGELOOP에서 문자열이 종료되었음을 알 수 있도록 함 (널문자)

times 510 - ( $ - $$ ) db 0x00 ; $는 현재 라인의 주소이고 $$는 현재 섹션(.text)의 시작 주소
							   ; $ - $$는 현재 섹션을 기준으로 하는 오프셋 의미
							   ; 510 - ( $ - $$ )는 현재부터 510번째 주소까지를 의미
							   ; db 0x00는 1바이트를 선언하고 값은 0x00를 의미
							   ; time은 반복 수행
							   ; 따라서, 현재 위치에서 510번째 주소까지 0x00로 초기화

db 0x55 ; 1바이트를 선언하고 값은 0x55
db 0xAA ; 1바이트를 선언하고 값은 0xAA
	    ; 511번째와 512번째 주소는 0x55와 0xAA로 초기화 -> 부트 섹터라는 것을 의미함
